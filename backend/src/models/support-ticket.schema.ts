import mongoose, { Schema } from "mongoose";
import { SupportTicketCounterModel } from "./support-ticket-counter.schema";
import {
  AssetType,
  IssueCategory,
  SupportTicketLog,
  TicketPriority,
  TicketStatus,
  TicketType,
} from "../types/support-ticket";

// Interface for the base Support Ticket
interface ISupportTicket {
  ticketId?: string; // optional, this will be auto-generated by the pre-hook
  type: TicketType;
  employeeName: string;
  employeeEmail: string;
  managerName: string;
  managerEmail: string;
  supportingFiles?: string[];
  status?: TicketStatus;
  createdBy: string;
  updatedBy?: string;
  notes?: string;
  priority?: TicketPriority;
  activityLog?: SupportTicketLog[];
}

// Interface for Issue Report Ticket
interface IIssueReportTicket extends ISupportTicket {
  type: TicketType.IssueReport;
  issueCategory: IssueCategory;
  assetAffected?: string;
  issueDescription: string;
}

// Interface for Asset Request Ticket
interface IAssetRequestTicket extends ISupportTicket {
  type: TicketType.AssetRequest;
  assetType: AssetType;
  assetSpecsModel: string;
  justification: string;
  requestedDate?: Date;
}

// Schema for the base Support Ticket
const supportTicketSchema: Schema<ISupportTicket> = new Schema<ISupportTicket>(
  {
    ticketId: {
      type: String,
      required: false,
      unique: true,
    },
    type: {
      type: String,
      required: true,
      enum: Object.values(TicketType),
    },
    employeeName: {
      type: String,
      required: true,
    },
    employeeEmail: {
      type: String,
      required: true,
    },
    managerName: {
      type: String,
      required: true,
    },
    managerEmail: {
      type: String,
      required: true,
    },
    supportingFiles: {
      type: [String], // Array of file URLs
      required: false,
      default: [],
    },
    status: {
      type: String,
      required: false,
      enum: Object.values(TicketStatus),
      default: TicketStatus.PendingManager,
    },
    createdBy: {
      type: String,
      required: true,
    },
    updatedBy: {
      type: String,
      required: false,
    },
    notes: {
      type: String,
      required: false,
      default: "",
    },
    priority: {
      type: String,
      required: false,
      default: TicketPriority.Low,
      enum: Object.values(TicketPriority),
    },
    activityLog: {
      type: [Object],
      required: true,
    },
  },
  {
    timestamps: true,
    discriminatorKey: "type",
  }
);

// Serves as a middleware to generate ticketId based on the ticket's type
supportTicketSchema.pre("save", async function (next) {
  if (this.isNew) {
    const prefix = this.type === TicketType.IssueReport ? "IR" : "AR";

    try {
      // findOneAndUpdate guarantees atomicity :)
      const ticketCounter = await SupportTicketCounterModel.findOneAndUpdate(
        { prefix: prefix },
        { $inc: { sequence: 1 } },
        { new: true, upsert: true }
      );
      if (!ticketCounter) {
        throw new Error(
          `Support Ticket Counter update failed for prefix: ${prefix}`
        );
      }

      const nextSequence = String(ticketCounter.sequence).padStart(4, "0");
      this.ticketId = `${prefix}-${nextSequence}`;
      this.updatedBy = this.createdBy;
    } catch (error) {
      return next(error as mongoose.CallbackError);
    }
  }
  next();
});

// Model for the base Support Ticket
const SupportTicketModel = mongoose.model<ISupportTicket>(
  "SupportTicket",
  supportTicketSchema
);

// Schema for Issue Report Ticket
const issueReportSchema: Schema<IIssueReportTicket> =
  new Schema<IIssueReportTicket>({
    issueCategory: {
      type: String,
      required: true,
      enum: Object.values(IssueCategory),
    },
    assetAffected: {
      type: String,
      required: false,
    },
    issueDescription: {
      type: String,
      required: true,
    },
  });

// Model for Issue Report Ticket
const IssueReportTicketModel =
  SupportTicketModel.discriminator<IIssueReportTicket>(
    TicketType.IssueReport,
    issueReportSchema
  );

// Schema for Asset Request Ticket
const assetRequestSchema: Schema<IAssetRequestTicket> =
  new Schema<IAssetRequestTicket>({
    assetType: {
      type: String,
      required: true,
      enum: Object.values(AssetType),
    },
    assetSpecsModel: {
      type: String,
      required: true,
    },
    justification: {
      type: String,
      required: true,
    },
    requestedDate: {
      type: Date,
      required: false,
    },
  });

// Model for Asset Request Ticket
const AssetRequestTicketModel =
  SupportTicketModel.discriminator<IAssetRequestTicket>(
    TicketType.AssetRequest,
    assetRequestSchema
  );

export {
  SupportTicketModel, // Support Ticket Base Model
  AssetRequestTicketModel, // Asset Request Model
  IssueReportTicketModel, // Issue Report Model
  ISupportTicket, // interfaces
  IIssueReportTicket, // interfaces
  IAssetRequestTicket, // interfaces
  supportTicketSchema, // schema
  issueReportSchema, // schema
  assetRequestSchema, // schema
};
